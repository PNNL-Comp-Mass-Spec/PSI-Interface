using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace CV_Generator
{
	public class CVWriter
	{
		private OBO_File _unimod;
		private OBO_File _psiMs;
		private List<OBO_File> _psiMsImports;
		private List<OBO_File> _allObo = new List<OBO_File>();

		public CVWriter()
		{
			Read();
		}

		private void Read()
		{
			var unimod = new Unimod_obo_Reader();
			unimod.Read();
			_unimod = unimod.FileData;

			var psiMs = new PSI_MS_obo_Reader();
			psiMs.Read();
			_psiMs = psiMs.FileData;
			_psiMsImports = psiMs.ImportedFileData;

			_allObo.Add(_psiMs);
			_allObo.Add(_unimod);
			_allObo.AddRange(_psiMsImports);
		}

		public void WriteFile(string filename)
		{
			using (StreamWriter file = new StreamWriter(new FileStream(filename, FileMode.Create, FileAccess.ReadWrite, FileShare.None)))
			{
				file.WriteLine(Header());
				file.WriteLine(UsingAndNamespace());
				// Write main class open...
                file.WriteLine(ClassOpen());
				PopulateTermDict();
				//file.WriteLine(TermInfoType("        "));
				//file.WriteLine(RelationsTypes("        "));
				file.WriteLine(GenerateRelationOtherTypesEnum("        "));
                file.WriteLine(GenerateCVEnum("        "));
                file.WriteLine(GenerateTermInfoObject("        "));
				file.WriteLine(RelationsIsAEnum("        "));
				// Write main class close...
                file.WriteLine(ClassClose());
                file.WriteLine(NamespaceClose());
			}
		}

		private string Header()
		{
			return "// DO NOT EDIT THIS FILE!\n" +
				"// This file is autogenerated from the internet-sourced OBO files.\n" +
				"// Any edits made will be lost when it is recreated.\n";
		}

		private string UsingAndNamespace()
		{
			return "// Using statements:\n" +
                "using System.Collections.Generic;\n" +
				"\n" +
				"namespace PSI_Interface.CV\n{\n";
		}

	    private string ClassOpen()
	    {
	        return "    public static partial class CV\n" +
	               "    {\n";
	    }

	    private string ClassClose()
	    {
	        return "    }\n";
	    }

	    private string NamespaceClose()
	    {
	        return "}\n";
	    }

		private string TermInfoType(string indent)
		{
			return indent + "public class TermInfo\n" +
				   indent + "{\n" +
				   indent + "    public CVID Cvid { get; private set; }\n" +
				   indent + "    public string Id { get; private set; }\n" +
			       indent + "    public string Name { get; private set; }\n" +
				   indent + "    public string Definition { get; private set; }\n" +
				   indent + "    public bool isObsolete { get; private set; }\n" +
				   indent + "    \n" +
				   indent + "    public TermInfo(CVID pCVID, string pId, string pName, string pDef, bool pIsObs)\n" +
				   indent + "    {\n" +
				   indent + "        Cvid = pCVID;\n" +
				   indent + "        Id = pId;\n" +
				   indent + "        Name = pName;\n" +
				   indent + "        Definition = pDef;\n" +
				   indent + "        IsObsolete = pIsObs;\n" +
				   indent + "    }\n" +
				   indent + "}\n";
		}

		private string RelationsTypes(string indent)
		{
		    return
		        indent + "public static readonly Dictionary<CVID, List<CVID>> RelationsIsA = new Dictionary<CVID, List<CVID>>();\n" +
		        indent + "public static readonly Dictionary<CVID, List<CVID>> RelationsPartOf = new Dictionary<CVID, List<CVID>>();\n" +
		        indent + "public static readonly Dictionary<CVID, List<string>> RelationsExactSynonym = new Dictionary<CVID, List<string>>();\n" +
		        indent + "public static readonly Dictionary<CVID, Dictionary<" + RelationsOtherTypesEnumName + ", List<CVID>>> RelationsOther = new Dictionary<CVID, Dictionary<" + RelationsOtherTypesEnumName + ", List<CVID>>>();\n" +
		        indent + "public static readonly Dictionary<CVID, TermInfo> TermData = new Dictionary<CVID, TermInfo>();\n";
		}

		private const string RelationsOtherTypesEnumName = "RelationsOtherTypes";

		//public enum RelationsOtherTypes : int
		//{
		//	has_units,
		//	Unknown,
		//	has_order,
		//	has_domain,
		//	has_regexp,
		//
		//}

		private string GenerateRelationOtherTypesEnum(string indent)
		{
			string enumData = indent + "public enum " + RelationsOtherTypesEnumName + " : int\n" + indent + "{\n";
			var dict = new Dictionary<string, int>();
			dict.Add("Unknown", 0);
			foreach (var obo in _allObo)
			{
				foreach (var typedef in obo.Typedefs.Values)
				{
					// Remove all duplicates, and automatically create new items....
					dict[typedef.Id] = 0;
				}
			}
			// part_of sets are separate.
			if (dict.ContainsKey("part_of"))
			{
				dict.Remove("part_of");
			}
			foreach (var key in dict.Keys)
			{
				enumData += indent + "    " + key + ",\n";
			}
			return enumData + indent + "}\n";
		}

        private Dictionary<string, OBO_File.OBO_Term> _cvEnumData = new Dictionary<string, OBO_File.OBO_Term>();

	    private void PopulateCVEnumData()
	    {
            string invalidSymbols = @" @/[():^?*+<=!~`#$%&{}|;'.,>\"; // WARNING: '-' must be at beginning or end, in middle it must be escaped, or it is interpreted as a range
            string invalidSymbolsEscaped = System.Text.RegularExpressions.Regex.Escape(invalidSymbols);
            string invalidSymbolsRegex = @"[\]\s" + invalidSymbolsEscaped + "\\-\\\"]"; // add all whitespace matching, manually escape the ']', since above call doesn't

            // Add "CVID_Unknown" to the list first
	        var unknown = new OBO_File.OBO_Term();
	        unknown.Id = "??:0000000";
	        unknown.Name = "CVID_Unknown";
	        unknown.EnumName = "CVID_Unknown";
	        unknown.Def = "CVID_Unknown [Unknown]";
	        unknown.IsObsolete = false;
            _cvEnumData.Add("CVID_Unknown", unknown);

            const string obsol = "_OBSOLETE";
            foreach (var obo in _allObo)
            {
                if (obo.IsGeneratedId && obo.Terms.Count > 0)
                {
                    string tempId = obo.Terms.Values.ToList()[0].Id;
                    tempId = tempId.Split(':')[0];
                    obo.Id = tempId;
                }
                var id = obo.Id;

                foreach (var term in obo.Terms.Values)
                {
                    string name = id + "_";
                    //name += term.Name.Replace(' ', '_');
                    name += System.Text.RegularExpressions.Regex.Replace(term.Name, invalidSymbolsRegex, "_");
                    //name += System.Text.RegularExpressions.Regex.Replace(term.Name.Replace(' ', '_'), invalidSymbolsRegex, "_");
                    if (term.IsObsolete)
                    {
                        name += obsol;
                    }
                    string tName = name;
                    int counter = 0;
                    while (_cvEnumData.ContainsKey(name))
                    {
                        counter++;
                        name = tName + counter;
                    }
                    _cvEnumData.Add(name, term);
                    term.EnumName = name;
                }
            }
	    }

		private string GenerateCVEnum(string indent)
        {
            if (_cvEnumData.Count == 0)
            {
                PopulateCVEnumData();
            }

			string enumData = indent + "public enum CVID : int\n" + indent + "{\n";
			foreach (var term in _cvEnumData.Values)
			{
				if (!string.IsNullOrWhiteSpace(term.Def))
				{
					enumData += indent + "    // " + term.DefShort + "\n";
				}
				enumData += indent + "    " + term.EnumName + ",\n\n";
			}
			return enumData + indent + "}\n";
		}

        private string GenerateTermInfoObject(string indent)
        {
            if (_cvEnumData.Count == 0)
            {
                PopulateCVEnumData();
            }

            string dictData = indent + "private static void PopulateTermData()\n" + indent + "{\n";
            foreach (var term in _cvEnumData.Values)
            {
                dictData += indent + "    TermData.Add(" + "CVID." + term.EnumName + ", new TermInfo(" + "CVID." +
                            term.EnumName + ", @\"" + term.Id + "\", @\"" + term.Name + "\", @\"" + term.DefShort + "\", " + term.IsObsolete.ToString().ToLower() + "));\n";
                //TermData as list
                //dictData += indent + "    TermData.Add(new TermInfo(" + "CVID." + term.EnumName + ", @\"" + term.Id +
                //            "\", @\"" + term.Name + "\", @\"" + term.DefShort + "\", " + term.IsObsolete.ToString().ToLower() + "));\n";
            }
            return dictData + indent + "}\n\n";
        }

		private readonly Dictionary<string, OBO_File.OBO_Term> _bigTermDict = new Dictionary<string, OBO_File.OBO_Term>();
		private bool _bigTermDictPopulated = false;

		private void PopulateTermDict()
		{
			if (_bigTermDictPopulated)
			{
				return;
			}
			foreach (var obo in _allObo)
			{
				foreach (var term in obo.Terms)
				{
					_bigTermDict.Add(term.Key, term.Value);
				}
			}
			_bigTermDictPopulated = true;
		}

		private string RelationsIsAEnum(string indent)
		{
			var items = new Dictionary<string, List<string>>();
			foreach (var obo in _allObo)
			{
				foreach (var term in obo.Terms.Values)
				{
					if (term.IsA.Count > 0)
					{
						items.Add(term.EnumName, new List<string>());
						foreach (var rel in term.IsA)
						{
							string rel2 = rel.Trim().Split(' ')[0];
							if (_bigTermDict.ContainsKey(rel2))
							{
								items[term.EnumName].Add(_bigTermDict[rel2].EnumName);
							}
						}
						if (items[term.EnumName].Count <= 0)
						{
							items.Remove(term.EnumName);
						}
					}
				}
			}

			string fillData = indent + "private static void FillRelationsIsA()\n" + indent + "{\n";
			foreach (var item in items)
			{
				//RelationsIsA.Add("name", new List<string> { "ref", "ref2", });
				fillData += indent + "    RelationsIsA.Add(" + "CVID." + item.Key + ", new List<CVID> { ";
				foreach (var map in item.Value)
				{
					fillData += "CVID." + map + ", ";
				}
				fillData += "});\n";
			}
			return fillData + indent + "}\n";
		}
	}
}
