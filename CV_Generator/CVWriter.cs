using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace CV_Generator
{
	public class CVWriter
	{
		private OBO_File _unimod;
		private OBO_File _psiMs;
		private List<OBO_File> _psiMsImports;
		private List<OBO_File> _allObo = new List<OBO_File>();

		public CVWriter()
		{
			Read();
		}

		private void Read()
		{
			var unimod = new Unimod_obo_Reader();
			unimod.Read();
			_unimod = unimod.FileData;

			var psiMs = new PSI_MS_obo_Reader();
			psiMs.Read();
			_psiMs = psiMs.FileData;
			_psiMsImports = psiMs.ImportedFileData;

			_allObo.Add(_psiMs);
			_allObo.Add(_unimod);
			_allObo.AddRange(_psiMsImports);
		}

		private void WriteFile(string filename)
		{
			using (StreamWriter file = new StreamWriter(new FileStream(filename, FileMode.Create, FileAccess.ReadWrite, FileShare.None)))
			{
				file.WriteLine(Header());
				file.WriteLine(UsingAndNamespace());
				// Write main class open...
				PopulateTermDict();
				file.WriteLine(TermInfoType("\t\t"));
				file.WriteLine(RelationsTypes("\t\t"));
				file.WriteLine(GenerateRelationOtherTypesEnum("\t\t"));
				file.WriteLine(GenerateCVEnumAndNames("\t\t"));
				file.WriteLine(RelationsIsAEnum("\t\t"));
				// Write main class close...


			}
		}

		private string Header()
		{
			return "// DO NOT EDIT THIS FILE!\n" +
				"// This file is autogenerated from the internet-sourced OBO files.\n" +
				"// Any edits made will be lost when it is recreated.\n";
		}

		private string UsingAndNamespace()
		{
			return "// Using statements:\n" +
				"\n" +
				"namespace PSI_Interface.CV\n{\n";
		}

		private string TermInfoType(string indent)
		{
			return indent + "public class TermInfo\n" +
				   indent + "{\n" +
				   indent + "\tpublic CVID Cvid { get; private set; }\n" +
				   indent + "\tpublic string Id { get; private set; }\n" +
			       indent + "\tpublic string Name { get; private set; }\n" +
				   indent + "\tpublic string Definition { get; private set; }\n" +
				   indent + "\tpublic bool isObsolete { get; private set; }\n" +
				   indent + "\t\n" +
				   indent + "\tpublic TermInfo(CVID pCVID, string pId, string pName, string pDef, bool pIsObs)\n" +
				   indent + "\t{\n" +
				   indent + "\t\tCvid = pCVID;\n" +
				   indent + "\t\tId = pId;\n" +
				   indent + "\t\tName = pName;\n" +
				   indent + "\t\tDefinition = pDef;\n" +
				   indent + "\t\tIsObsolete = pIsObs;\n" +
				   indent + "\t}\n" +
				   indent + "}\n";
		}

		private string RelationsTypes(string indent)
		{
			return
				indent + "public readonly Dictionary<CVID, List<CVID>> RelationsIsA = new Dictionary<CVID, List<CVID>>();\n" +
				indent + "public readonly Dictionary<CVID, List<CVID>> RelationsPartOf = new Dictionary<CVID, List<CVID>>();\n" +
				indent + "public readonly Dictionary<CVID, List<string>> RelationsExactSynonym = new Dictionary<CVID, List<string>>();\n" +
				indent + "public readonly Dictionary<CVID, Dictionary<" + RelationsOtherTypesEnumName + ", List<CVID>>> RelationsOther = new Dictionary<CVID, Dictionary<" + RelationsOtherTypesEnumName + ", List<CVID>>>();\n";
		}

		private const string RelationsOtherTypesEnumName = "RelationsOtherTypes";

		//public enum RelationsOtherTypes : int
		//{
		//	has_units,
		//	Unknown,
		//	has_order,
		//	has_domain,
		//	has_regexp,
		//
		//}

		private string GenerateRelationOtherTypesEnum(string indent)
		{
			string enumData = indent + "public enum " + RelationsOtherTypesEnumName + " : int\n" + indent + "{\n";
			var dict = new Dictionary<string, int>();
			dict.Add("Unknown", 0);
			foreach (var obo in _allObo)
			{
				foreach (var typedef in obo.Typedefs.Values)
				{
					// Remove all duplicates, and automatically create new items....
					dict[typedef.Id] = 0;
				}
			}
			// part_of sets are separate.
			if (dict.ContainsKey("part_of"))
			{
				dict.Remove("part_of");
			}
			foreach (var key in dict.Keys)
			{
				enumData += indent + "\t" + key + ",\n";
			}
			return enumData + indent + "}\n";
		}

		private string GenerateCVEnumAndNames(string indent)
		{
			var names = new Dictionary<string, OBO_File.OBO_Term>();
			const string obsol = "_OBSOLETE";
			foreach (var obo in _allObo)
			{
				if (obo.IsGeneratedId && obo.Terms.Count > 0)
				{
					string tempId = obo.Terms.Values.ToList()[0].Id;
					tempId = tempId.Split(':')[0];
					obo.Id = tempId;
				}
				var id = obo.Id;

				foreach (var term in obo.Terms.Values)
				{
					string name = id + "_";
					name += term.Name.Replace(' ', '_');
					if (term.IsObsolete)
					{
						name += obsol;
					}
					string tName = name;
					int counter = 0;
					while (names.ContainsKey(name))
					{
						counter++;
						name = tName + counter;
					}
					names.Add(name, term);
					term.EnumName = name;
				}
			}

			string enumData = indent + "public enum CVID : int\n" + indent + "{\n";
			enumData += indent + "\tCVID_Unknown,\n\n";
			foreach (var term in names.Values)
			{
				if (!string.IsNullOrWhiteSpace(term.Def))
				{
					enumData += indent + "\t// " + term.DefShort + "\n";
				}
				enumData += indent + "\t" + term.EnumName + ",\n\n";
			}
			return enumData + indent + "}\n";
		}

		private readonly Dictionary<string, OBO_File.OBO_Term> _bigTermDict = new Dictionary<string, OBO_File.OBO_Term>();
		private bool _bigTermDictPopulated = false;

		private void PopulateTermDict()
		{
			if (_bigTermDictPopulated)
			{
				return;
			}
			foreach (var obo in _allObo)
			{
				foreach (var term in obo.Terms)
				{
					_bigTermDict.Add(term.Key, term.Value);
				}
			}
			_bigTermDictPopulated = true;
		}

		private string RelationsIsAEnum(string indent)
		{
			var items = new Dictionary<string, List<string>>();
			foreach (var obo in _allObo)
			{
				foreach (var term in obo.Terms.Values)
				{
					if (term.IsA.Count > 0)
					{
						items.Add(term.EnumName, new List<string>());
						foreach (var rel in term.IsA)
						{
							string rel2 = rel.Trim().Split(' ')[0];
							if (_bigTermDict.ContainsKey(rel2))
							{
								items[term.EnumName].Add(_bigTermDict[rel2].EnumName);
							}
						}
						if (items[term.EnumName].Count <= 0)
						{
							items.Remove(term.EnumName);
						}
					}
				}
			}

			string fillData = indent + "private void FillRelationsIsA()\n" + indent + "{\n";
			foreach (var item in items)
			{
				//RelationsIsA.Add("name", new List<string> { "ref", "ref2", });
				fillData += indent + "\tRelationsIsA.Add(" + item.Key + ", new List<CVID> { ";
				foreach (var map in item.Value)
				{
					fillData += map + ", ";
				}
				fillData += "});\n";
			}
			return fillData + indent + "}\n";
		}
	}
}
